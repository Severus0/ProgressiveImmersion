

===== ./config.js =====
import browser from 'webextension-polyfill'; if ( !browser.action ) { browser.action = browser.browserAction; } const { languages: LANGUAGES } = require( 'google-translate-api-x' ); const DEFAULT_UPDATE_FREQUENCY = 12; const DEFAULT_MIN_WORD_LENGTH = 4; const DEFAULT_WORDS_TO_SAVE = 5; const DEFAULT_FILTER_MAX_SHARE_OF_WORDS = 0.0075; const DEFAULT_FILTER_MIN_SHARE_OF_WORDS = 0.001; export { browser, LANGUAGES, DEFAULT_UPDATE_FREQUENCY, DEFAULT_MIN_WORD_LENGTH, DEFAULT_WORDS_TO_SAVE, DEFAULT_FILTER_MAX_SHARE_OF_WORDS, DEFAULT_FILTER_MIN_SHARE_OF_WORDS };

===== ./translateWord.js =====
import translate from 'google-translate-api-x'; const MAX_TRANSLATE_ATTEMPTS = 3; async function translateWord ( word, origin, target ) { for ( let attempts = 0; attempts < MAX_TRANSLATE_ATTEMPTS; attempts++ ) { try { const res = await translate( word, { from: origin, to: target, forceBatch: false }); return res.text.toLowerCase(); } catch ( _ ) { null; } } throw 'Never successfully translated!'; } export default translateWord;

===== ./options/index.js =====
import { DEFAULT_FILTER_MAX_SHARE_OF_WORDS, DEFAULT_FILTER_MIN_SHARE_OF_WORDS, DEFAULT_MIN_WORD_LENGTH, DEFAULT_UPDATE_FREQUENCY, DEFAULT_WORDS_TO_SAVE, browser } from '../config'; browser.storage.local.get( 'updateFrequency' ).then( ( value ) => { document.getElementById( 'updateFrequency' ).value = value.updateFrequency ?? DEFAULT_UPDATE_FREQUENCY; if ( value.updateFrequency === undefined ) { browser.storage.local.set({ updateFrequency: DEFAULT_UPDATE_FREQUENCY }); } }); document.getElementById( 'updateFrequency' ).oninput = () => { const updateFrequency = parseFloat( document.getElementById( 'updateFrequency' ).value ); browser.storage.local.set({ updateFrequency: updateFrequency }); }; document.getElementById( 'updateFrequencyReset' ).onclick = () => { document.getElementById( 'updateFrequency' ).value = DEFAULT_UPDATE_FREQUENCY; browser.storage.local.set({ updateFrequency: DEFAULT_UPDATE_FREQUENCY }); }; browser.storage.local.get( 'minWordLength' ).then( ( value ) => { document.getElementById( 'minWordLength' ).value = value.minWordLength ?? DEFAULT_MIN_WORD_LENGTH; if ( value.minWordLength === undefined ) { browser.storage.local.set({ minWordLength: DEFAULT_MIN_WORD_LENGTH }); } }); document.getElementById( 'minWordLength' ).oninput = () => { const minWordLength = parseFloat( document.getElementById( 'minWordLength' ).value ); browser.storage.local.set({ minWordLength: minWordLength }); }; document.getElementById( 'minWordLengthReset' ).onclick = () => { document.getElementById( 'minWordLength' ).value = DEFAULT_MIN_WORD_LENGTH; browser.storage.local.set({ minWordLength: DEFAULT_MIN_WORD_LENGTH }); }; browser.storage.local.get( 'wordsToSave' ).then( ( value ) => { document.getElementById( 'wordsToSave' ).value = value.wordsToSave ?? DEFAULT_WORDS_TO_SAVE; if ( value.wordsToSave === undefined ) { browser.storage.local.set({ wordsToSave: DEFAULT_WORDS_TO_SAVE }); } }); document.getElementById( 'wordsToSave' ).oninput = () => { const wordsToSave = parseFloat( document.getElementById( 'wordsToSave' ).value ); browser.storage.local.set({ wordsToSave: wordsToSave }); }; document.getElementById( 'wordsToSaveReset' ).onclick = () => { document.getElementById( 'wordsToSave' ).value = DEFAULT_WORDS_TO_SAVE; browser.storage.local.set({ wordsToSave: DEFAULT_WORDS_TO_SAVE }); }; browser.storage.local.get( 'filterMaxShareOfWords' ).then( ( value ) => { document.getElementById( 'filterMaxShareOfWords' ).value = value.filterMaxShareOfWords ?? DEFAULT_FILTER_MAX_SHARE_OF_WORDS; if ( value.filterMaxShareOfWords === undefined ) { browser.storage.local.set({ filterMaxShareOfWords: DEFAULT_FILTER_MAX_SHARE_OF_WORDS }); } }); document.getElementById( 'filterMaxShareOfWords' ).oninput = () => { const filterMaxShareOfWords = parseFloat( document.getElementById( 'filterMaxShareOfWords' ).value ); browser.storage.local.set({ filterMaxShareOfWords: filterMaxShareOfWords }); }; document.getElementById( 'filterMaxShareOfWordsReset' ).onclick = () => { document.getElementById( 'filterMaxShareOfWords' ).value = DEFAULT_FILTER_MAX_SHARE_OF_WORDS; browser.storage.local.set({ filterMaxShareOfWords: DEFAULT_FILTER_MAX_SHARE_OF_WORDS }); }; browser.storage.local.get( 'filterMinShareOfWords' ).then( ( value ) => { document.getElementById( 'filterMinShareOfWords' ).value = value.filterMinShareOfWords ?? DEFAULT_FILTER_MIN_SHARE_OF_WORDS; if ( value.filterMinShareOfWords === undefined ) { browser.storage.local.set({ filterMinShareOfWords: DEFAULT_FILTER_MIN_SHARE_OF_WORDS }); } }); document.getElementById( 'filterMinShareOfWords' ).oninput = () => { const filterMinShareOfWords = parseFloat( document.getElementById( 'filterMinShareOfWords' ).value ); browser.storage.local.set({ filterMinShareOfWords: filterMinShareOfWords }); }; document.getElementById( 'filterMinShareOfWordsReset' ).onclick = () => { document.getElementById( 'filterMinShareOfWords' ).value = DEFAULT_FILTER_MIN_SHARE_OF_WORDS; browser.storage.local.set({ filterMinShareOfWords: DEFAULT_FILTER_MIN_SHARE_OF_WORDS }); };

===== ./options/index.html =====
<!DOCTYPE html> <html> <head> <meta charset="utf-8" /> </head> <body> <h2>Advanced Options</h2> <form> <label for="updateFrequency"><b>New word frequency:</b></label> <input type="number" id="updateFrequency" name="updateFrequency" class="browser-style"> <input type="button" id="updateFrequencyReset" class="browser-style" value="Reset"><br> <label for="minWordLength"><b>Minimum word length to translate:</b></label> <input type="number" id="minWordLength" name="minWordLength" class="browser-style"> <input type="button" id="minWordLengthReset" class="browser-style" value="Reset"><br> <label for="wordsToSave"><b>Words to save to the queue per page:</b></label> <input type="number" id="wordsToSave" name="wordsToSave" class="browser-style"> <input type="button" id="wordsToSaveReset" class="browser-style" value="Reset"><br> <label for="filterMaxShareOfWords"><b>Maximum occurences of a word in a page:</b></label> <input type="number" id="filterMaxShareOfWords" name="filterMaxShareOfWords" class="browser-style"> <input type="button" id="filterMaxShareOfWordsReset" class="browser-style" value="Reset"><br> <label for="filterMinShareOfWords"><b>Minimum occurences of a word in a page:</b></label> <input type="number" id="filterMinShareOfWords" name="filterMinShareOfWords" class="browser-style"> <input type="button" id="filterMinShareOfWordsReset" class="browser-style" value="Reset"><br> </form> <script src="index.js"></script> </body> </html>

===== ./background_scripts/main.js =====
import { browser } from '../config'; import updateDictionary from './dictionary-handler'; import { exportToAnki } from './export-anki'; browser.storage.local.get( [ 'state', 'latestWordTime', 'updateFrequency', 'origin', 'originNativeName', 'target', 'targetNativeName' ] ).then( value => { if ( value.state === undefined ){ value.state = false; browser.storage.local.set({ state: false }); } if ( value.origin === undefined || value.originNativeName === undefined ) { browser.storage.local.set({ origin: 'en', originNativeName: 'English' }); } if ( value.target === undefined || value.targetNativeName === undefined ) { browser.storage.local.set({ target: 'es', targetNativeName: 'Spanish' }); } if ( value.latestWordTime === undefined ) { value.latestWordTime = Date.now(); browser.storage.local.set({ latestWordTime: value.latestWordTime }); } if ( value.state ){ browser.action.setBadgeText({ text: 'On' }); browser.action.setBadgeBackgroundColor({ color: 'green' }); awaitNextWord( value ); } else { browser.action.setBadgeText({ text: 'Off' }); browser.action.setBadgeBackgroundColor({ color: 'red' }); } }); browser.storage.onChanged.addListener( ( changes, areaName ) => { if ( areaName === 'local' ) { if ( changes.updateFrequency || changes.state ) { browser.storage.local.get( [ 'state', 'latestWordTime', 'updateFrequency' ] ).then( value => { browser.alarms.clearAll(); if ( value.state === true ) { awaitNextWord( value ); } }); } } }); function awaitNextWord ( value ) { const nextWordTime = value.latestWordTime + ( ( value.updateFrequency !== undefined ? value.updateFrequency : 12 ) * 60 * 60 * 1000 ); browser.alarms.create({ when: nextWordTime }); } browser.alarms.onAlarm.addListener( () => { browser.storage.local.get( [ 'updateFrequency' ] ).then( value => { value.latestWordTime = Date.now(); updateDictionary(); browser.storage.local.set({ latestWordTime: value.latestWordTime }); awaitNextWord( value ); }); }); browser.runtime.onMessage.addListener((msg) => { if (msg.type === 'EXPORT_ANKI') { exportToAnki(); } });

===== ./background_scripts/dictionary-handler.js =====
import { browser } from '../config'; import translateWord from '../translateWord'; function updateDictionary (){ browser.storage.local.get( [ 'wordpack', 'wordpackIndex', 'wordQueue', 'origin', 'target', 'dictionary' ] ).then( async value => { if ( value.origin === undefined || value.target === undefined || value.wordQueue === undefined || value.wordQueue.length === 0 ) { return; } if ( value.dictionary === undefined ) { value.dictionary = {}; } if ( value.dictionary[value.origin] === undefined ) { value.dictionary[value.origin] = {}; } if ( value.dictionary[value.origin][value.target] === undefined ) { value.dictionary[value.origin][value.target] = {}; } let word = value.wordQueue.sort( ( a, b ) => a[1] - b[1] ).pop(); while ( value.dictionary[value.origin][value.target][word[0]] !== undefined ) { word = value.wordQueue.pop(); if ( word === undefined ) { browser.storage.local.set({ wordQueue: value.wordQueue }); return; } } try { value.dictionary[value.origin][value.target][word[0]] = await translateWord( word[0], value.origin, value.target ); browser.storage.local.set({ dictionary: value.dictionary, wordQueue: value.wordQueue }); } catch ( _ ) { null; } }); } export default updateDictionary;

===== ./background_scripts/export-anki.js =====
import { browser } from '../config'; export async function exportToAnki() { const value = await browser.storage.local.get('dictionary'); const dictionary = value.dictionary ?? {}; const text = JSON.stringify(dictionary, null, 2); const blob = new Blob([text], { type: 'application/json' }); const url = URL.createObjectURL(blob); await browser.downloads.download({ url: url, filename: 'progressive-immersion-dictionary.json', saveAs: true }); URL.revokeObjectURL(url); }

===== ./popup/language-select.html =====
<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css"> </head> <body style="width: 200px;"> <ul class="w3-ul" id="languageList"> <li class="w3-li"><h3 id="title"></h3></li> </ul> <script src="language-select.js"></script> </body> </html>

===== ./popup/dictionary-list.js =====
import { LANGUAGES, browser } from '../config'; const dictionaryList = document.getElementById( 'dictionaryList' ); browser.storage.local.get( [ 'dictionary', 'target', 'origin' ] ).then( value => { if ( value.dictionary === undefined ) { value.dictionary = {}; } if ( value.dictionary[value.origin] === undefined ) { value.dictionary[value.origin] = {}; } if ( value.dictionary[value.origin][value.target] === undefined ) { value.dictionary[value.origin][value.target] = {}; } for ( const origin in value.dictionary ) { for ( const target in value.dictionary[origin] ) { const listItem = document.createElement( 'li' ); const button = document.createElement( 'a' ); button.classList.add( 'w3-button' ); button.textContent = LANGUAGES[origin] + ' -> ' + LANGUAGES[target]; button.href = 'dictionary.html#' + origin + '~' + target + '~' + LANGUAGES[origin] + '~' + LANGUAGES[target]; listItem.appendChild( button ); dictionaryList.appendChild( listItem ); } } });

===== ./popup/index.js =====
import { DEFAULT_UPDATE_FREQUENCY, browser } from '../config'; let state; browser.storage.local.get( 'state' ).then( ( value ) => { state = value.state; if ( state === undefined ){ state = false; browser.storage.local.set({ state: state }); } document.getElementById( 'onSwitch' ).checked = state; updateBadgeState(); }); function updateBadgeState (){ if ( state ){ browser.action.setBadgeText({ text: 'On' }); browser.action.setBadgeBackgroundColor({ color: 'green' }); } else { browser.action.setBadgeText({ text: 'Off' }); browser.action.setBadgeBackgroundColor({ color: 'red' }); } } document.getElementById( 'onSwitch' ).addEventListener( 'click', () => { state = document.getElementById( 'onSwitch' ).checked; updateBadgeState(); browser.storage.local.set({ state: state }); }); browser.storage.local.get( 'updateFrequency' ).then( ( value ) => { document.getElementById( 'updateSlider' ).value = ( value.updateFrequency !== undefined ) ? value.updateFrequency : DEFAULT_UPDATE_FREQUENCY; document.getElementById( 'updateSliderText' ).innerHTML = `New words every ${document.getElementById( 'updateSlider' ).value} hours`; if ( value.updateFrequency === undefined ) { browser.storage.local.set({ updateFrequency: DEFAULT_UPDATE_FREQUENCY }); } }); document.getElementById( 'updateSlider' ).oninput = () => { const updateFrequency = parseFloat( document.getElementById( 'updateSlider' ).value ); document.getElementById( 'updateSliderText' ).innerHTML = `New words every ${updateFrequency.toPrecision( 3 )} hours`; browser.storage.local.set({ updateFrequency: updateFrequency }); }; browser.storage.local.get( 'originNativeName' ).then( ( value ) => { document.getElementById( 'originButton' ).innerHTML = value.originNativeName; }); browser.storage.local.get( 'targetNativeName' ).then( ( value ) => { document.getElementById( 'targetButton' ).innerHTML = value.targetNativeName; }); browser.storage.local.get( 'exclusionListMode' ).then( ( value ) => { if ( value.exclusionListMode === 'whitelist' ){ document.getElementById( 'whitelistCheck' ).checked = true; } else { document.getElementById( 'blacklistCheck' ).checked = true; } }); browser.storage.local.get( 'exclusionList' ).then( ( value ) => { if ( value.exclusionList ){ document.getElementById( 'exclusionList' ).value = value.exclusionList.join( '\n' ); } }); document.getElementById( 'exclusionListMode' ).oninput = () => { if ( document.getElementById( 'whitelistCheck' ).checked ) { browser.storage.local.set({ exclusionListMode: 'whitelist' }); } else { browser.storage.local.set({ exclusionListMode: 'blacklist' }); } }; document.getElementById( 'exclusionList' ).addEventListener( 'input', () => { browser.storage.local.set({ exclusionList: document.getElementById( 'exclusionList' ).value.trim().split( '\n' ) }); }); document.getElementById('exportAnkiBtn') ?.addEventListener('click', () => { browser.runtime.sendMessage({ type: 'EXPORT_ANKI' }); });

===== ./popup/dictionary.html =====
<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css"> <style> td { min-width: 175px; } </style> </head> <body> <table class="w3-table w3-striped" id="dictionary"> <tr> <th id="source-title"></th> <th id="target-title"></th> <td> </td> </tr> <tr> <td> <input id="source-word" class="w3-input w3-border" type="text" placeholder="Source Word"> </td> <td> <input id="translated-word" class="w3-input w3-border" type="text" placeholder="Translated Word"> </td> <th> <button id="submit-word" class="w3-button w3-green">Submit</button> </th> </tr> </table> <script src="dictionary.js"></script> </body> </html>

===== ./popup/language-select.js =====
import { LANGUAGES, browser } from '../config'; document.getElementById( 'title' ).innerHTML = ( window.location.hash === '#origin' ) ? 'Source Language' : 'Target Language'; const languageList = document.getElementById( 'languageList' ); for ( const isoCode in LANGUAGES ) { if ( typeof LANGUAGES[isoCode] === 'function' ) { continue; } if ( window.location.hash === '#target' && isoCode === 'auto' ) { continue; } const listItem = document.createElement( 'li' ); const button = document.createElement( 'button' ); button.classList.add( 'w3-button' ); button.innerHTML = LANGUAGES[isoCode]; button.isoCode = isoCode; button.nativeName = LANGUAGES[isoCode]; button.addEventListener( 'click', ( e ) => { browser.storage.local.set({ [window.location.hash.slice( 1 )]: e.target.isoCode }); browser.storage.local.set({ [window.location.hash.slice( 1 ) + 'NativeName']: e.target.nativeName }); window.location.href = './index.html'; }); listItem.appendChild( button ); languageList.appendChild( listItem ); }

===== ./popup/dictionary-list.html =====
<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css"> </head> <body> <ul class="w3-ul" id="dictionaryList"> <li><h3>Dictionaries</h3></li> </ul> <footer class="w3-center"> <input type="file" id="import-file" accept=".json" style="display:none" /> </footer> <script src="dictionary-list.js"></script> </body> </html>

===== ./popup/dictionary.js =====
import { browser } from '../config'; import translateWord from '../translateWord'; const dictionary = document.getElementById( 'dictionary' ); const [ originIso, targetIso, originName, targetName ] = window.location.hash.slice( 1 ).split( '~' ); document.getElementById( 'source-title' ).textContent = originName; document.getElementById( 'target-title' ).textContent = targetName; browser.storage.local.get( 'dictionary' ).then( value => { if ( value.dictionary === undefined ) { value.dictionary = {}; } if ( value.dictionary[originIso] === undefined ) { value.dictionary[originIso] = {}; } if ( value.dictionary[originIso][targetIso] === undefined ) { value.dictionary[originIso][targetIso] = {}; } for ( const word in value.dictionary[originIso][targetIso] ) { drawTranslation( word, value.dictionary[originIso][targetIso][word] ); } const sourceWordInput = document.getElementById( 'source-word' ); const translatedWordInput = document.getElementById( 'translated-word' ); document.getElementById( 'submit-word' ).addEventListener( 'click', async e => { if ( sourceWordInput.value === '' ) { return; } const sourceWord = sourceWordInput.value.toLowerCase(); if ( translatedWordInput.value === '' ) { try { translatedWordInput.value = await translateWord( sourceWord, originIso, targetIso ); } catch ( _ ) { return; } } value.dictionary[originIso][targetIso][sourceWord] = translatedWordInput.value.toLowerCase(); browser.storage.local.set({ dictionary: value.dictionary }); drawTranslation( sourceWord, translatedWordInput.value.toLowerCase() ); sourceWordInput.value = ''; translatedWordInput.value = ''; }); document.addEventListener( 'keypress', ( e ) => { if ( e.key === 'Enter' ) { e.preventDefault(); document.getElementById( 'submit-word' ).click(); } }); function drawTranslation ( original, translated ) { const row = dictionary.insertRow( dictionary.rows.length - 1 ); const [ originalElem, targetElem ] = [ document.createElement( 'td' ), document.createElement( 'td' ) ]; [ originalElem.textContent, targetElem.textContent ] = [ original, translated ]; row.appendChild( originalElem ); row.appendChild( targetElem ); const deleteButtonHeader = document.createElement( 'th' ); const deleteButton = document.createElement( 'button' ); deleteButton.textContent = 'Delete'; deleteButton.classList.add( 'w3-button', 'w3-red' ); deleteButton.addEventListener( 'click', e => { delete value.dictionary[originIso][targetIso][original]; browser.storage.local.set({ dictionary: value.dictionary }); row.remove(); }); deleteButtonHeader.appendChild( deleteButton ); row.appendChild( deleteButtonHeader ); } if ( Object.keys( value.dictionary[originIso][targetIso] ).length === 0 ) { const caption = dictionary.createCaption(); caption.classList.add( 'w3-blue', 'w3-card' ); caption.textContent = 'Your dictionary is currently empty, try using the extension more. Or, you can add words manually below.'; } });

===== ./popup/index.html =====
<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <link rel="stylesheet" href="index.css"/> <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css"> </head> <body> <div class="w3-bar"> <h2 class="w3-bar-item">Progressive Immersion</h2> </div> <table class="w3-table w3-striped"> <tr> <th> On/Off </th> <td> <label class="switch"> <input type="checkbox" id="onSwitch"> <span class="slider"></span> </label> </td> </tr> <tr> <th id="updateSliderText"> New words every 12.0 hours </th> <td> <div class="range-slide-container"> <input type="range" min="0.5" max="96" value="12.0" class="range-slider" id="updateSlider" step="0.5"> </div> </td> </tr> <tr> <th class="w3-right-align w3-padding-16"> Translate from: </th> <td class="w3-left-align"> <a id="originButton" class="w3-button" href="language-select.html#origin"></a> </td> </tr> <tr> <th class="w3-right-align w3-padding-16"> Translate to: </th> <td class="w3-left-align"> <a id="targetButton" class="w3-button" href="language-select.html#target"></a> <a class="w3-button" href="dictionary-list.html">[Dictionaries]</a> </td> </tr> <tr id="exclusionListMode"> <td class="w3-padding" style="margin-left: 900px;"> <label class="check-container">Whitelist: <input id="whitelistCheck" type="radio" name="exclusionListMode" value="whitelist"> <span class="checkmark"></span> </label> </td> <td class="w3-padding"> <label class="check-container">Blacklist: <input id="blacklistCheck" type="radio" name="exclusionListMode" value="blacklist"> <span class="checkmark"></span> </label> </td> </tr> </table> <textarea class="w3-input w3-border w3-light-grey" id="exclusionList" rows="5" placeholder="Put each entry on its own line, include more of the URL to be more specific."></textarea> <div class="w3-center" style="margin-top:10px;"> <button id="exportAnkiBtn" class="w3-button w3-blue"> Export to Anki </button> </div> <script src="index.js"></script> </body> </html>

===== ./popup/index.css =====
.switch { position: relative; display: inline-block; width: 60px; height: 34px; } .switch input { opacity: 0; width: 0; height: 0; } .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; -webkit-transition: .4s; transition: .4s; border-radius: 34px; } .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; -webkit-transition: .4s; transition: .4s; border-radius: 50%; } input:checked + .slider { background-color: #2196F3; } input:focus + .slider { box-shadow: 0 0 1px #2196F3; } input:checked + .slider:before { -webkit-transform: translateX(18px); -ms-transform: translateX(18px); transform: translateX(18px); } .range-slider { -webkit-appearance: none; width: 100%; height: 15px; border-radius: 5px; background: #d3d3d3; outline: none; opacity: 0.7; -webkit-transition: .2s; transition: opacity .2s; } .range-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 25px; height: 25px; border-radius: 50%; background: #2196F3; cursor: pointer; } .range-slider::-moz-range-thumb { width: 25px; height: 25px; border-radius: 50%; background: #2196F3; cursor: pointer; } .check-container { font-size: medium; display: block; position: relative; padding-left: 35px; margin-bottom: 12px; cursor: pointer; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .check-container input { position: absolute; opacity: 0; cursor: pointer; height: 0; width: 0; } .checkmark { position: absolute; top: 0; left: 0; height: 25px; width: 25px; background-color: #eee; } .check-container:hover input ~ .checkmark { background-color: #ccc; } .check-container input:checked ~ .checkmark { background-color: #2196F3; } .checkmark:after { content: ""; position: absolute; display: none; } .check-container input:checked ~ .checkmark:after { display: block; } .check-container .checkmark:after { left: 11px; top: 7px; width: 5px; height: 10px; border: solid white; border-width: 0 3px 3px 0; -webkit-transform: rotate(45deg); -ms-transform: rotate(45deg); transform: rotate(45deg); }

===== ./content_scripts/main.js =====
import { DEFAULT_MIN_WORD_LENGTH, browser } from '../config'; import countWord from './analyze'; import translate from './translate'; function capitalizationPermutations ( stringArray ){ const result = []; for ( const s of stringArray ) { result.push( s.toUpperCase() ); result.push( s.toLowerCase() ); } return result; } const TAGS_TO_TRANSLATE = capitalizationPermutations( [ 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'th', 'td', 'a', 'i', 'em', 'strong', 'mark', 'ul', 'main', 'yt-formatted-string', 'yt-attributed-string' ] ); const TAGS_TO_TRANSLATE_WHEN_NESTED_IN_TRACKED_TAGS = capitalizationPermutations( [ 'div', 'span' ] ); let dictionary = undefined; let origin = undefined; let target = undefined; let minWordLength = DEFAULT_MIN_WORD_LENGTH; function checkAncestorInTags ( node, tags ) { if ( !Array.isArray( tags ) ) { tags = [ tags ]; } if ( node.parentNode && tags.includes( node.parentNode.tagName ) ) { return true; } return node.parentNode !== null ? checkAncestorInTags( node.parentNode, tags ) : false; } function checkShouldTranslateNode ( node ) { return TAGS_TO_TRANSLATE.includes( node.tagName ) || ( TAGS_TO_TRANSLATE_WHEN_NESTED_IN_TRACKED_TAGS.includes( node.tagName ) && checkAncestorInTags( node, TAGS_TO_TRANSLATE ) ); } browser.storage.local.get( [ 'state', 'dictionary', 'origin', 'target', 'minWordLength', 'exclusionList', 'exclusionListMode' ] ).then( value => { let isExcluded = false; value.exclusionListMode = value.exclusionListMode ?? 'blacklist'; if ( value.exclusionList !== undefined ) { isExcluded = value.exclusionList.some( exclusion => { if ( exclusion === '' ) { return false; } return value.exclusionListMode === 'blacklist' ? window.location.href.includes( exclusion ) : !window.location.href.includes( exclusion ); }); } if ( !value.state || isExcluded ){ return; } const mutationObserver = new MutationObserver( function ( mutationRecords ) { for ( const mutation of mutationRecords ) { if ( ( mutation.type === 'characterData' || mutation.type === 'attributes' ) && mutation.target.innerText && checkShouldTranslateNode( mutation.target ) ) { viewObserver.observe( mutation.target ); return; } if ( !mutation.addedNodes ) { return; } for ( const addedNode of mutation.addedNodes ) { ( function observeNodesAndChildren ( node ){ if ( checkShouldTranslateNode( node ) ) { if ( node.innerText ) { viewObserver.observe( node ); } mutationObserver.observe( node, { characterData: true, attributes: true }); } if ( node.nodeType !== Node.ELEMENT_NODE ) { return; } for ( const child of node.children ) { observeNodesAndChildren( child ); } })( addedNode ); } } }); mutationObserver.observe( document.body, { subtree: true, childList: true }); dictionary = value.dictionary; origin = value.origin; target = value.target; minWordLength = value.minWordLength ?? minWordLength; const elems = document.body.querySelectorAll( TAGS_TO_TRANSLATE.join( ',' ) ); for ( const elem of elems ){ if ( elem.innerText ){ viewObserver.observe( elem ); } mutationObserver.observe( elem, { characterData: true, attributes: true }); } const nestedElems = document.body.querySelectorAll( TAGS_TO_TRANSLATE_WHEN_NESTED_IN_TRACKED_TAGS.join( ',' ) ); for ( const nestedElem of nestedElems ) { if ( checkAncestorInTags( nestedElem, TAGS_TO_TRANSLATE ) ){ if ( nestedElem.innerText ) { viewObserver.observe( nestedElem ); } mutationObserver.observe( nestedElem, { characterData: true, attributes: true }); } } }); const viewObserver = new IntersectionObserver( ( entries ) => { const matchWords = /(?<=^|[\P{L}])(?<![0-9])\p{L}+(?![0-9])(?=$|\P{L})/gu; for ( const entry of entries ) { if ( !entry.isIntersecting || entry.target.progressiveImmersionAnalyzed ) { continue; } entry.target.progressiveImmersionAnalyzed = true; for ( const node of entry.target.childNodes ){ if ( node.nodeType !== Node.TEXT_NODE ) { continue; } matchWords.lastIndex = 0; let matchedArray; while ( ( matchedArray = matchWords.exec( node.textContent ) ) !== null ) { const [ word ] = matchedArray; const wordLower = word.toLowerCase(); if ( word.length >= minWordLength ) { countWord( wordLower ); } translate( wordLower, matchedArray, node, entry.target, dictionary, origin, target ); } } } });

===== ./content_scripts/analyze.js =====
import { DEFAULT_FILTER_MAX_SHARE_OF_WORDS, DEFAULT_FILTER_MIN_SHARE_OF_WORDS, DEFAULT_WORDS_TO_SAVE, browser } from '../config'; let wordsToSave = DEFAULT_WORDS_TO_SAVE; let filterMaxShareOfWords = DEFAULT_FILTER_MAX_SHARE_OF_WORDS; let filterMinShareOfWords = DEFAULT_FILTER_MIN_SHARE_OF_WORDS; browser.storage.local.get( [ 'filterMaxShareOfWords', 'filterMinShareOfWords', 'wordsToSave' ] ).then( value => { filterMaxShareOfWords = value.filterMaxShareOfWords ?? filterMaxShareOfWords; filterMinShareOfWords = value.filterMinShareOfWords ?? filterMinShareOfWords; wordsToSave = value.wordsToSave ?? wordsToSave; }); const wordTally = new Map(); function countWord ( word ) { if ( !wordTally.has( word ) ){ wordTally.set( word, 0 ); } wordTally.set( word, wordTally.get( word ) + 1 ); } window.onbeforeunload = () => { browser.storage.local.get( [ 'state', 'wordQueue' ] ).then( ( value ) => { if ( value.state ){ analyzeWordTally( value ); } }); }; function analyzeWordTally ( value ){ if ( value.wordQueue === undefined ) { value.wordQueue = []; } const time = Date.now(); for ( let i = 0; i < value.wordQueue.length; i++ ){ const instances = wordTally.get( value.wordQueue[i][0] ); if ( instances !== undefined ){ value.wordQueue[i][1] += instances; value.wordQueue[i][2] = time; wordTally.delete( value.wordQueue[i][0] ); } } let tallyArray = [ ...wordTally ].sort( ( a, b ) => b[1] - a[1] ); let totalWords = 0; for ( let i = 0; i < tallyArray.length; ++i ){ totalWords += tallyArray[i][1]; } tallyArray = tallyArray.filter( ( a ) => ( ( a[1]/totalWords ) <= filterMaxShareOfWords ) && ( ( a[1]/totalWords ) >= filterMinShareOfWords ) ); tallyArray = tallyArray.slice( 0, wordsToSave ); for ( let i = 0; i < tallyArray.length; i++ ){ if ( value.wordQueue.length < 100 ) { tallyArray[i].push( time ); value.wordQueue.push( tallyArray[i] ); } } browser.storage.local.set({ wordQueue: value.wordQueue }); } export default countWord;

===== ./content_scripts/translate.js =====
function translate ( wordLower, matchedArray, textNode, intersectionTarget, dictionary, origin, target ) { if ( dictionary?.[origin]?.[target] === undefined ) { return; } const dictionaryPage = dictionary[origin][target]; if ( !Object.prototype.hasOwnProperty.call( dictionaryPage, wordLower ) ) { return; } const { 0: originalWord, index: wordIndex } = matchedArray; let translated = dictionaryPage[wordLower]; if ( wordLower.toUpperCase() === originalWord ) { translated = translated.toUpperCase(); } else if ( wordLower !== originalWord ) { translated = translated.charAt( 0 ).toUpperCase() + translated.slice( 1 ); } const wordElement = document.createElement( 'progressive-immersion-word' ); wordElement.setAttribute( 'data-original-word', originalWord ); wordElement.setAttribute( 'data-translated-word', translated ); wordElement.innerHTML = translated; wordElement.addEventListener( 'mouseover', e => { e.target.innerHTML = e.target.getAttribute( 'data-original-word' ) ?? ''; }); wordElement.addEventListener( 'mouseout', e => { e.target.innerHTML = e.target.getAttribute( 'data-translated-word' ) ?? ''; }); const otherTextHalf = textNode.splitText( wordIndex ); otherTextHalf.textContent = otherTextHalf.textContent.slice( originalWord.length ); intersectionTarget.insertBefore( wordElement, otherTextHalf ); } export default translate;